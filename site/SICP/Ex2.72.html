<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Smatchcube | Exercise 2.72</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>body {max-width: 1000px;padding: 15px; margin: auto; font-family: sans;}</style>
<link rel="stylesheet" href="/style.css">
<style>
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>
</head>
<body>
<header>
  <h1>Smatchcube's website  üåç</h1>
  <hr>
</header>
<nav>
<p>/<a href="/">home</a>/<a href="/SICP.html">SICP</a>/Exercise 2.72</p>
</nav>
<main>
<div id="header">
<h1 class="title">Exercise 2.72</h1>
</div>
<p>This kind of question is really difficult, my answer is a big approximation.\ We will give the order of growth in the case the tree is shaped as in the previous exercise.\ The answer is dependent of my <code>encode-symbol</code> procedure so here is mine:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb1-1" title="1">(<span class="ex">define</span><span class="fu"> </span>(encode-symbol symbol tree)</a>
<a class="sourceLine" id="cb1-2" title="2">  (<span class="ex">define</span><span class="fu"> </span>(encode-symbol-checking-only-left symbol tree)</a>
<a class="sourceLine" id="cb1-3" title="3">    (<span class="kw">if</span> (leaf? tree)</a>
<a class="sourceLine" id="cb1-4" title="4">        &#39;()</a>
<a class="sourceLine" id="cb1-5" title="5">        (<span class="kw">let</span> ((left (left-branch tree))</a>
<a class="sourceLine" id="cb1-6" title="6">              (right (right-branch tree)))</a>
<a class="sourceLine" id="cb1-7" title="7">          (<span class="kw">if</span> (element-of-set? symbol (symbols left))</a>
<a class="sourceLine" id="cb1-8" title="8">              (<span class="kw">cons</span> <span class="dv">0</span> (encode-symbol-checking-only-left symbol left))</a>
<a class="sourceLine" id="cb1-9" title="9">              (<span class="kw">cons</span> <span class="dv">1</span> (encode-symbol-checking-only-left symbol right))))))</a>
<a class="sourceLine" id="cb1-10" title="10">  (<span class="kw">if</span> (element-of-set? symbol (symbols tree))</a>
<a class="sourceLine" id="cb1-11" title="11">      (encode-symbol-checking-only-left symbol tree)</a>
<a class="sourceLine" id="cb1-12" title="12">      (error <span class="st">&quot;bad symbol: ENCODE-SYMBOL&quot;</span> symbol)))</a></code></pre></div>
<p>For the most frequent element we only need to check in the element is in the tree and if the first left branch contain the most frequent element so the order of grow of the number of steps needed to encode the most frequent element is \((n)\) (for checking if the element is in the ‚Äúalphabet‚Äù).\ For the least frequent element the order of growth is also \((n)\) (but requiring two times more steps than for the most frequent element) because we need to check if the element is in the tree and then traverse the tree of depth \(n\) checking if the element is in the left branch containing each time only one element.\ My <code>encode-symbol</code> procedure is really optimized for this kind of tree.</p>
</main>
<footer>
<hr>
</footer>
</body>
</html>
